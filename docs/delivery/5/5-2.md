# [5-2] Create data aggregation service for report metrics

[Back to task list](./tasks.md)

## Description

Build a Python service that aggregates transaction data for reporting purposes. This service will provide methods to calculate monthly totals, category breakdowns, income vs expenses, and other metrics needed for charts.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-19 23:25:00 | Created | N/A | Proposed | Task file created | Saeed |
| 2025-10-19 23:35:00 | Status Change | Proposed | Agreed | Task approved | Saeed |
| 2025-10-19 23:35:00 | Status Change | Agreed | InProgress | Started implementation | Saeed |
| 2025-10-19 23:55:00 | Status Change | InProgress | Done | ReportService complete with 4 aggregation methods, 11 unit tests passing | Saeed |

## Requirements

### Functional Requirements
1. Create `ReportService` class in `src/services/report_service.py`
2. Implement method `get_monthly_income_expenses(account_id=None, start_date=None, end_date=None)`
   - Returns list of months with total income and total expenses
3. Implement method `get_category_breakdown(account_id=None, start_date=None, end_date=None)`
   - Returns expenses grouped by top-level category with totals
4. Implement method `get_monthly_category_trends(account_id=None, start_date=None, end_date=None)`
   - Returns monthly data with breakdown by category
5. Implement method `get_top_categories(account_id=None, start_date=None, end_date=None, limit=10)`
   - Returns top N spending categories with totals
6. All methods should support filtering by account and date range
7. Handle cases where no data exists (return empty structures)

### Non-Functional Requirements
- Methods should be efficient (use SQL aggregation, not Python loops)
- Return data in JSON-friendly format (dicts/lists, no pandas DataFrames)
- All amounts should be properly signed (positive for income, negative for expenses)
- Dates should be in ISO format (YYYY-MM-DD)
- Handle database errors gracefully

## Implementation Plan

### Step 1: Create service file structure
```python
# src/services/report_service.py

from datetime import datetime, date
from typing import Optional, List, Dict, Any
from flask import current_app
import sqlite3

class ReportService:
    """Service for generating financial report data"""
    
    def __init__(self, db_path: str):
        self.db_path = db_path
    
    def _get_connection(self):
        """Get database connection"""
        return sqlite3.connect(self.db_path)
```

### Step 2: Implement get_monthly_income_expenses
```python
def get_monthly_income_expenses(
    self,
    account_id: Optional[int] = None,
    start_date: Optional[date] = None,
    end_date: Optional[date] = None
) -> List[Dict[str, Any]]:
    """
    Get monthly income and expense totals.
    
    Returns: [
        {
            "month": "2025-01",
            "income": 5000.00,
            "expenses": 3500.00,
            "net": 1500.00
        },
        ...
    ]
    """
```

Logic:
- Query transactions grouped by strftime('%Y-%m', date)
- Sum amounts where amount > 0 (income)
- Sum absolute amounts where amount < 0 (expenses)
- Calculate net = income - expenses
- Apply filters for account_id and date range
- Order by month ascending

### Step 3: Implement get_category_breakdown
```python
def get_category_breakdown(
    self,
    account_id: Optional[int] = None,
    start_date: Optional[date] = None,
    end_date: Optional[date] = None
) -> List[Dict[str, Any]]:
    """
    Get spending breakdown by category.
    
    Returns: [
        {
            "category": "Groceries",
            "amount": 850.25,
            "percentage": 24.3,
            "transaction_count": 45
        },
        ...
    ]
    """
```

Logic:
- Join transactions with categories table
- Group by top-level category name
- Sum absolute amounts for negative transactions only
- Calculate percentage of total
- Count transactions per category
- Order by amount descending

### Step 4: Implement get_monthly_category_trends
```python
def get_monthly_category_trends(
    self,
    account_id: Optional[int] = None,
    start_date: Optional[date] = None,
    end_date: Optional[date] = None
) -> Dict[str, Any]:
    """
    Get monthly expenses broken down by category.
    
    Returns: {
        "months": ["2025-01", "2025-02", ...],
        "categories": {
            "Groceries": [850, 920, 880, ...],
            "Rent": [2000, 2000, 2000, ...],
            ...
        }
    }
    """
```

Logic:
- Get list of all months in range
- For each month, get expenses by category
- Pivot data into format suitable for stacked bar chart
- Only include top 10 categories by total spend
- Group others into "Other" category

### Step 5: Implement get_top_categories
```python
def get_top_categories(
    self,
    account_id: Optional[int] = None,
    start_date: Optional[date] = None,
    end_date: Optional[date] = None,
    limit: int = 10
) -> List[Dict[str, Any]]:
    """
    Get top spending categories.
    
    Returns: [
        {
            "category": "Rent",
            "amount": 6000.00,
            "transaction_count": 3,
            "avg_per_transaction": 2000.00
        },
        ...
    ]
    """
```

Logic:
- Similar to category_breakdown but with limit
- Add average per transaction
- Order by total amount descending

### Step 6: Add helper methods
- `_apply_filters(query, params, account_id, start_date, end_date)` - Add WHERE clauses
- `_format_date(date_obj)` - Convert date to string
- `_parse_date(date_str)` - Convert string to date

## Test Plan

### Unit Tests
Create `tests/unit/test_report_service.py`:

1. **test_monthly_income_expenses_basic**
   - Insert test transactions (income and expenses)
   - Call `get_monthly_income_expenses()`
   - Assert correct monthly totals

2. **test_monthly_income_expenses_filtered_by_account**
   - Insert transactions for multiple accounts
   - Call with specific account_id
   - Assert only that account's transactions included

3. **test_monthly_income_expenses_filtered_by_date**
   - Insert transactions across multiple months
   - Call with specific date range
   - Assert only transactions in range included

4. **test_category_breakdown**
   - Insert categorized transactions
   - Call `get_category_breakdown()`
   - Assert correct totals and percentages

5. **test_monthly_category_trends**
   - Insert transactions across months and categories
   - Call `get_monthly_category_trends()`
   - Assert correct data structure and values

6. **test_top_categories**
   - Insert many categories
   - Call `get_top_categories(limit=5)`
   - Assert top 5 returned, ordered correctly

7. **test_empty_data**
   - Call all methods with no transactions
   - Assert empty structures returned (not errors)

8. **test_uncategorized_transactions**
   - Insert transactions without categories
   - Verify they appear as "Uncategorized"

### Success Criteria
- All unit tests pass (8+ tests)
- Methods return correct data structures
- Filtering works correctly (account, date range)
- No errors with empty database
- Efficient SQL queries (no N+1 problems)
- Data format matches API requirements

## Verification

### Definition of Done
- [x] `ReportService` class created with all required methods
- [x] All methods implemented and working
- [x] Methods support filtering by account and date range
- [x] Unit tests created and passing (8+ tests)
- [x] Data returned in JSON-friendly format
- [x] Empty data handled gracefully
- [x] Code reviewed for performance

### Testing Evidence
- Unit test results showing 8+ tests passing
- Example output from each method
- Performance test with 10,000+ transactions

## Files Modified

### New Files
- `src/services/report_service.py` - Report data aggregation service
- `tests/unit/test_report_service.py` - Unit tests for report service

### Modified Files
- None (standalone service)

## Notes

- Consider adding caching for expensive queries if needed
- Category hierarchy: use level-1 categories for grouping
- For "Uncategorized" transactions, use special handling
- SQL queries should use indexes (date, account_id, category_id)
- Consider adding method for year-over-year comparison in future
- All monetary amounts should be returned as floats, rounded to 2 decimals

